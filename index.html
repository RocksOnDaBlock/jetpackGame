<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jetpack Adventure</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #222;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none; /* Standard syntax */
            touch-action: manipulation;
            height: 100vh;
            width: 100vw;
        }
        
        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background-color: #87CEEB;
        }
        
        #player {
            position: absolute;
            width: 5vmin;
            height: 7vmin;
            left: 10vw;
            transition: transform 0.1s;
            z-index: 50;
        }
        
        .player-body {
            position: absolute;
            width: 3vmin;
            height: 4vmin;
            background-color: #FF5733;
            border-radius: 8px 8px 0 0;
            bottom: 0;
            left: 1vmin;
        }
        
        .player-head {
            position: absolute;
            width: 2vmin;
            height: 2vmin;
            background-color: #FFC0CB;
            border-radius: 50%;
            bottom: 4vmin;
            left: 1.5vmin;
        }
        
        .player-arm {
            position: absolute;
            width: 0.8vmin;
            height: 2vmin;
            background-color: #FFC0CB;
            bottom: 2vmin;
        }
        
        .player-arm.left {
            left: 0.2vmin;
            transform-origin: bottom;
        }
        
        .player-arm.right {
            right: 0.2vmin;
            transform-origin: bottom;
        }
        
        .player-leg {
            position: absolute;
            width: 1vmin;
            height: 1.5vmin;
            background-color: #4169E1;
            bottom: 0;
        }
        
        .player-leg.left {
            left: 1.2vmin;
        }
        
        .player-leg.right {
            right: 1.2vmin;
        }
        
        .jetpack {
            position: absolute;
            width: 2vmin;
            height: 3vmin;
            background-color: #555;
            border-radius: 5px;
            left: -0.5vmin;
            bottom: 1.5vmin;
        }
        
        .jetpack-flame {
            position: absolute;
            width: 1.5vmin;
            height: 2.5vmin;
            background: linear-gradient(to bottom, #FFC300, #FF5733);
            border-radius: 0 0 50% 50%;
            left: -0.2vmin;
            bottom: -2vmin;
            opacity: 0;
            transition: opacity 0.1s;
        }
        
        .obstacle {
            position: absolute;
            background-color: #FF005C;
            border-radius: 0;
            z-index: 60;
            box-shadow: 0 0 15px #FF005C;
        }
        
        .vertical-laser {
            width: 0.8vmin; 
            border-radius: 0.4vmin;
        }
        
        .horizontal-laser {
            height: 0.8vmin;
            border-radius: 0.4vmin;
        }
        
        .laser-emitter {
            position: absolute;
            width: 2vmin;
            height: 2vmin;
            background-color: #444;
            border-radius: 4px;
            z-index: 60;
        }
        
        .coin {
            position: absolute;
            width: 2vmin;
            height: 2vmin;
            background-color: gold;
            border-radius: 50%;
            box-shadow: 0 0 5px gold;
            z-index: 45;
        }
        
        .powerup {
            position: absolute;
            width: 3vmin;
            height: 3vmin;
            border-radius: 5px;
            box-shadow: 0 0 10px white;
            z-index: 45;
        }
        
        .invincibility {
            background-color: #FF9500;
        }
        
        .shield {
            background-color: #3498DB;
        }
        
        .ground {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 5vh;
            background-color: #8B4513;
            background-image: linear-gradient(to bottom, #8B4513, #654321);
            z-index: 40;
        }
        
        .ceiling {
            position: absolute;
            top: 0;
            width: 100%;
            height: 2vh;
            background-color: #696969;
            z-index: 40;
        }
        
        #score-display {
            position: absolute;
            top: 3vh;
            left: 2vw;
            color: white;
            font-size: calc(16px + 0.8vmin);
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 200;
            min-width: 300px;
            max-width: 90%;
        }
        
        .btn {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #FF5733;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: calc(14px + 0.4vmin);
            transition: background-color 0.3s;
        }
        
        .btn:hover {
            background-color: #FF7043;
        }
        
        #powerup-indicator {
            position: absolute;
            top: 7vh;
            left: 2vw;
            color: white;
            font-size: calc(14px + 0.5vmin);
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        #level-indicator {
            position: absolute;
            top: 11vh;
            left: 2vw;
            color: white;
            font-size: calc(14px + 0.5vmin);
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        #level-progress {
            position: absolute;
            top: 14vh;
            left: 2vw;
            width: 15vw;
            max-width: 150px;
            min-width: 100px;
            height: 1vh;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            overflow: hidden;
            z-index: 100;
        }
        
        #progress-bar {
            height: 100%;
            width: 0%;
            background-color: #FF5733;
            transition: width 0.3s;
        }
        
        #level-complete {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 190;
            min-width: 300px;
            max-width: 90%;
        }
        
        #level-complete h2 {
            margin-bottom: 10px;
            font-size: calc(20px + 1vmin);
        }
        
        #level-complete p {
            margin-bottom: 20px;
            font-size: calc(16px + 0.5vmin);
        }
        
        #title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #1a2a6c, #b21f1f, #fdbb2d);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }
        
        #title {
            font-size: calc(24px + 2vmin);
            color: white;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            margin-bottom: 3vh;
            text-align: center;
            padding: 0 20px;
        }
        
        #high-score {
            font-size: calc(16px + 0.8vmin);
            color: gold;
            margin-bottom: 2vh;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        
        #customization {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 3vh;
            width: 80%;
            max-width: 400px;
        }
        
        #customization h2 {
            color: white;
            text-align: center;
            margin-top: 0;
            font-size: calc(16px + 0.5vmin);
            margin-bottom: 15px;
        }
        
        .color-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .color-option label {
            color: white;
            flex: 1;
            font-size: calc(14px + 0.2vmin);
        }
        
        .color-option input {
            flex: 1;
        }
        
        #start-game-btn {
            padding: 15px 30px;
            font-size: calc(16px + 0.5vmin);
            background-color: #FF5733;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.3s;
        }
        
        #start-game-btn:hover {
            transform: scale(1.05);
            background-color: #FF7043;
        }
        
        #level-selection {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 3vh;
            width: 80%;
            max-width: 400px;
            color: white;
            text-align: center;
        }
        
        #level-selection h2 {
            margin-top: 0;
            font-size: calc(16px + 0.5vmin);
            margin-bottom: 15px;
        }
        
        .level-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .level-btn {
            width: calc(30px + 2vmin);
            height: calc(30px + 2vmin);
            border-radius: 50%;
            background-color: #3498DB;
            color: white;
            border: none;
            font-size: calc(14px + 0.4vmin);
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .level-btn:hover {
            transform: scale(1.1);
        }
        
        .level-btn.locked {
            background-color: #7f8c8d;
            cursor: not-allowed;
        }
        
        .level-btn.completed {
            background-color: #2ecc71;
        }
        
        .background-element {
            position: absolute;
            z-index: 10;
        }
        
        .cloud {
            background-color: white;
            border-radius: 50px;
            opacity: 0.8;
        }
        
        .mountain {
            background: linear-gradient(to bottom, #8B4513, #654321);
            clip-path: polygon(50% 0%, 100% 100%, 0% 100%);
        }
        
        .effect {
            position: absolute;
            z-index: 150;
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            #title {
                font-size: calc(24px + 1.5vmin);
            }
            
            #customization, #level-selection {
                width: 90%;
                padding: 15px;
            }
            
            .btn {
                padding: 8px 16px;
            }
        }
        
        @media (max-height: 600px) {
            #level-progress {
                top: 16vh;
            }
            
            #level-indicator {
                top: 12vh;
            }
            
            #powerup-indicator {
                top: 8vh;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="player">
            <div class="player-head"></div>
            <div class="player-body"></div>
            <div class="player-arm left"></div>
            <div class="player-arm right"></div>
            <div class="player-leg left"></div>
            <div class="player-leg right"></div>
            <div class="jetpack">
                <div class="jetpack-flame"></div>
            </div>
        </div>
        <div class="ground"></div>
        <div class="ceiling"></div>
        <div id="score-display">Score: 0</div>
        <div id="powerup-indicator"></div>
        <div id="level-indicator">Level: 1</div>
        <div id="level-progress">
            <div id="progress-bar"></div>
        </div>
        <div id="level-complete">
            <h2>Level Complete!</h2>
            <p>You completed Level <span id="completed-level">1</span>!</p>
            <button id="continue-btn" class="btn">Continue to Level <span id="next-level">2</span></button>
            <button id="level-menu-btn" class="btn">Back to Menu</button>
        </div>
        <div id="game-over">
            <h2>Game Over</h2>
            <p id="final-score">Your Score: 0</p>
            <p id="new-high-score" style="color: gold; display: none;">New High Score!</p>
            <button id="restart-btn" class="btn">Play Again</button>
            <button id="menu-btn" class="btn">Main Menu</button>
        </div>
    </div>

    <div id="title-screen">
        <h1 id="title">JETPACK ADVENTURE</h1>
        <div id="high-score">High Score: 0</div>
        
        <div id="level-selection">
            <h2>Select Level</h2>
            <div class="level-buttons" id="level-buttons-container">
                <!-- Level buttons will be generated here -->
            </div>
        </div>
        
        <div id="customization">
            <h2>Customize Character</h2>
            <div class="color-option">
                <label for="body-color">Body Color:</label>
                <input type="color" id="body-color" value="#FF5733">
            </div>
            <div class="color-option">
                <label for="skin-color">Skin Color:</label>
                <input type="color" id="skin-color" value="#FFC0CB">
            </div>
            <div class="color-option">
                <label for="pants-color">Pants Color:</label>
                <input type="color" id="pants-color" value="#4169E1">
            </div>
            <div class="color-option">
                <label for="jetpack-color">Jetpack Color:</label>
                <input type="color" id="jetpack-color" value="#555555">
            </div>
        </div>
        
        <button id="start-game-btn" class="btn">START GAME</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Game elements
            const gameContainer = document.getElementById('game-container');
            const player = document.getElementById('player');
            const jetpackFlame = document.querySelector('.jetpack-flame');
            const scoreDisplay = document.getElementById('score-display');
            const gameOverScreen = document.getElementById('game-over');
            const finalScoreDisplay = document.getElementById('final-score');
            const newHighScoreText = document.getElementById('new-high-score');
            const restartBtn = document.getElementById('restart-btn');
            const menuBtn = document.getElementById('menu-btn');
            const powerupIndicator = document.getElementById('powerup-indicator');
            const levelIndicator = document.getElementById('level-indicator');
            const progressBar = document.getElementById('progress-bar');
            const levelCompleteMessage = document.getElementById('level-complete');
            const completedLevelSpan = document.getElementById('completed-level');
            const nextLevelSpan = document.getElementById('next-level');
            const continueBtn = document.getElementById('continue-btn');
            const levelMenuBtn = document.getElementById('level-menu-btn');
            const titleScreen = document.getElementById('title-screen');
            const highScoreDisplay = document.getElementById('high-score');
            const startGameBtn = document.getElementById('start-game-btn');
            const levelButtonsContainer = document.getElementById('level-buttons-container');
            
            // Game dimensions
            let groundHeight, ceilingHeight, playerHeight, playerWidth, playerStartX;
            
            // Function to update responsive dimensions
            function updateDimensions() {
                // Get dimensions in pixels based on viewport units
                const vh = window.innerHeight / 100;
                const vw = window.innerWidth / 100;
                const vmin = Math.min(vh, vw);
                
                groundHeight = 5 * vh;
                ceilingHeight = 2 * vh;
                playerHeight = 7 * vmin;
                playerWidth = 5 * vmin;
                playerStartX = 10 * vw;
                
                // Update player position
                if (player) {
                    player.style.left = `${playerStartX}px`;
                }
            }
            
            // Initial dimension setup
            updateDimensions();
            
            // Update dimensions on resize
            window.addEventListener('resize', function() {
                updateDimensions();
                
                // If game is active, adjust player position
                if (gameActive && !gameOver && !levelPaused) {
                    const groundOffset = groundHeight + 10;
                    const maxY = gameContainer.clientHeight - playerHeight - groundHeight;
                    
                    // Ensure player stays within bounds
                    playerY = Math.min(maxY, Math.max(ceilingHeight, playerY));
                    player.style.bottom = `${playerY}px`;
                }
            });
            
            // Character customization elements
            const bodyColorInput = document.getElementById('body-color');
            const skinColorInput = document.getElementById('skin-color');
            const pantsColorInput = document.getElementById('pants-color');
            const jetpackColorInput = document.getElementById('jetpack-color');
            
            // Apply character colors
            function applyCharacterColors() {
                document.querySelector('.player-body').style.backgroundColor = bodyColorInput.value;
                document.querySelector('.player-head').style.backgroundColor = skinColorInput.value;
                document.querySelector('.player-arm.left').style.backgroundColor = skinColorInput.value;
                document.querySelector('.player-arm.right').style.backgroundColor = skinColorInput.value;
                document.querySelector('.player-leg.left').style.backgroundColor = pantsColorInput.value;
                document.querySelector('.player-leg.right').style.backgroundColor = pantsColorInput.value;
                document.querySelector('.jetpack').style.backgroundColor = jetpackColorInput.value;
                
                // Save colors to localStorage
                localStorage.setItem('bodyColor', bodyColorInput.value);
                localStorage.setItem('skinColor', skinColorInput.value);
                localStorage.setItem('pantsColor', pantsColorInput.value);
                localStorage.setItem('jetpackColor', jetpackColorInput.value);
            }
            
            // Load saved colors
            function loadSavedColors() {
                const savedBodyColor = localStorage.getItem('bodyColor');
                const savedSkinColor = localStorage.getItem('skinColor');
                const savedPantsColor = localStorage.getItem('pantsColor');
                const savedJetpackColor = localStorage.getItem('jetpackColor');
                
                if (savedBodyColor) bodyColorInput.value = savedBodyColor;
                if (savedSkinColor) skinColorInput.value = savedSkinColor;
                if (savedPantsColor) pantsColorInput.value = savedPantsColor;
                if (savedJetpackColor) jetpackColorInput.value = savedJetpackColor;
                
                applyCharacterColors();
            }
            
            // Load saved colors on start
            loadSavedColors();
            
            // Color input event listeners
            bodyColorInput.addEventListener('input', applyCharacterColors);
            skinColorInput.addEventListener('input', applyCharacterColors);
            pantsColorInput.addEventListener('input', applyCharacterColors);
            jetpackColorInput.addEventListener('input', applyCharacterColors);
            
            // Level configuration
            const levels = [
                { distance: 5000, obstacleFrequency: 0.02, obstacleSpeed: 5, background: '#87CEEB' },
                { distance: 7500, obstacleFrequency: 0.025, obstacleSpeed: 5.5, background: '#78A7C5' },
                { distance: 10000, obstacleFrequency: 0.03, obstacleSpeed: 6, background: '#6986AB' },
                { distance: 12500, obstacleFrequency: 0.035, obstacleSpeed: 6.5, background: '#5A6591' },
                { distance: 15000, obstacleFrequency: 0.04, obstacleSpeed: 7, background: '#4B4577' },
                { distance: 17500, obstacleFrequency: 0.045, obstacleSpeed: 7.5, background: '#3C245D' },
                { distance: 20000, obstacleFrequency: 0.05, obstacleSpeed: 8, background: '#2D0243' },
                { distance: 25000, obstacleFrequency: 0.055, obstacleSpeed: 8.5, background: '#1E0029' },
                { distance: 30000, obstacleFrequency: 0.06, obstacleSpeed: 9, background: '#0F001A' },
                { distance: 35000, obstacleFrequency: 0.07, obstacleSpeed: 10, background: '#000000' }
            ];
            
            // Game state
            let isJetpackActive = false;
            let playerY = gameContainer.clientHeight / 2;
            let playerVelocity = 0;
            let gravity = 0.5;
            let jetpackForce = 0.8;
            let gameSpeed = 5;
            let baseGameSpeed = 5;
            let score = 0;
            let highScore = localStorage.getItem('highScore') || 0;
            let obstacles = [];
            let coins = [];
            let powerups = [];
            let backgroundElements = [];
            let gameOver = false;
            let levelPaused = false;
            let animationFrameId = null;
            let gameActive = false;
            let currentLevel = 1;
            let distanceTraveled = 0;
            let levelTarget = levels[0].distance;
            let obstacleFrequency = levels[0].obstacleFrequency;
            let completedLevels = JSON.parse(localStorage.getItem('completedLevels')) || [];
            
            // Update high score display
            highScoreDisplay.textContent = `High Score: ${highScore}`;
            
            // Player state
            let hasShield = false;
            let shieldTimeLeft = 0;
            let isInvincible = false;
            let invincibilityTimeLeft = 0;
            let invincibilityGracePeriod = 0;
            
            // Initialize player position
            player.style.bottom = `${groundHeight + 10}px`;
            
            // Generate level selection buttons
            function generateLevelButtons() {
                levelButtonsContainer.innerHTML = '';
                for (let i = 0; i < levels.length; i++) {
                    const levelBtn = document.createElement('button');
                    levelBtn.className = 'level-btn';
                    levelBtn.textContent = i + 1;
                    
                    // Show locked/completed status
                    if (i > 0 && !completedLevels.includes(i)) {
                        if (!completedLevels.includes(i - 1)) {
                            levelBtn.classList.add('locked');
                        }
                    }
                    
                    if (completedLevels.includes(i)) {
                        levelBtn.classList.add('completed');
                    }
                    
                    levelBtn.addEventListener('click', function() {
                        // Only allow selecting unlocked levels
                        if (!levelBtn.classList.contains('locked')) {
                            selectLevel(i);
                        }
                    });
                    
                    levelButtonsContainer.appendChild(levelBtn);
                }
            }
            
            // Select level
            function selectLevel(levelIndex) {
                currentLevel = levelIndex + 1;
                levelTarget = levels[levelIndex].distance;
                obstacleFrequency = levels[levelIndex].obstacleFrequency;
                baseGameSpeed = levels[levelIndex].obstacleSpeed;
                gameSpeed = baseGameSpeed;
                
                // Set background color based on level
                gameContainer.style.backgroundColor = levels[levelIndex].background;
                
                // Generate background elements based on level
                generateBackgroundElements(levelIndex);
                
                startGame();
            }
            
            // Generate background elements based on level
            function generateBackgroundElements(levelIndex) {
                // Clear existing background elements
                while (backgroundElements.length > 0) {
                    gameContainer.removeChild(backgroundElements[0].element);
                    backgroundElements.shift();
                }
                
                // Number of elements scales with level
                const numClouds = Math.max(3, 6 - levelIndex);
                const numMountains = Math.min(5, Math.floor(levelIndex / 2) + 1);
                
                // Add clouds
                for (let i = 0; i < numClouds; i++) {
                    createBackgroundElement('cloud');
                }
                
                // Add mountains in later levels
                if (levelIndex >= 2) {
                    for (let i = 0; i < numMountains; i++) {
                        createBackgroundElement('mountain');
                    }
                }
            }
            
            // Create a background element
            function createBackgroundElement(type) {
                const element = document.createElement('div');
                element.className = 'background-element ' + type;
                
                let width, height, bottom, left;
                
                if (type === 'cloud') {
                    const vw = window.innerWidth / 100;
                    const vh = window.innerHeight / 100;
                    
                    width = Math.floor(Math.random() * 20 * vw) + 10 * vw;
                    height = Math.floor(Math.random() * 4 * vh) + 3 * vh;
                    bottom = Math.floor(Math.random() * (gameContainer.clientHeight - 200)) + 150;
                    left = Math.floor(Math.random() * gameContainer.clientWidth);
                    
                    // Add some depth/layering to clouds
                    const opacity = Math.random() * 0.4 + 0.4;
                    element.style.opacity = opacity;
                    
                    // Slower movement for distant clouds
                    const speed = Math.max(1, baseGameSpeed * (opacity - 0.3));
                    
                    backgroundElements.push({
                        element: element,
                        type: type,
                        position: left,
                        width: width,
                        speed: speed
                    });
                } else if (type === 'mountain') {
                    const vw = window.innerWidth / 100;
                    const vh = window.innerHeight / 100;
                    
                    width = Math.floor(Math.random() * 30 * vw) + 20 * vw;
                    height = Math.floor(Math.random() * 15 * vh) + 10 * vh;
                    bottom = groundHeight;
                    left = Math.floor(Math.random() * gameContainer.clientWidth);
                    
                    // Mountains move slower than game speed
                    const speed = baseGameSpeed * 0.3;
                    
                    backgroundElements.push({
                        element: element,
                        type: type,
                        position: left,
                        width: width,
                        speed: speed
                    });
                }
                
                element.style.width = `${width}px`;
                element.style.height = `${height}px`;
                element.style.bottom = `${bottom}px`;
                element.style.left = `${left}px`;
                
                gameContainer.appendChild(element);
            }
            
            // Event listeners for game controls
            function activateJetpack(e) {
                e.preventDefault();
                if (gameActive && !gameOver && !levelPaused) {
                    isJetpackActive = true;
                    jetpackFlame.style.opacity = '1';
                    
                    // Animate arms when jetpack is active
                    document.querySelector('.player-arm.left').style.transform = 'rotate(-30deg)';
                    document.querySelector('.player-arm.right').style.transform = 'rotate(30deg)';
                }
            }
            
            function deactivateJetpack(e) {
                e.preventDefault();
                isJetpackActive = false;
                jetpackFlame.style.opacity = '0';
                
                // Reset arm position
                document.querySelector('.player-arm.left').style.transform = 'rotate(0deg)';
                document.querySelector('.player-arm.right').style.transform = 'rotate(0deg)';
            }
            
            // Add game control event listeners
            function addGameControls() {
                document.addEventListener('mousedown', activateJetpack);
                document.addEventListener('mouseup', deactivateJetpack);
                document.addEventListener('touchstart', activateJetpack);
                document.addEventListener('touchend', deactivateJetpack);
                document.addEventListener('keydown', function(e) {
                    if (e.code === 'Space') activateJetpack(e);
                });
                document.addEventListener('keyup', function(e) {
                    if (e.code === 'Space') deactivateJetpack(e);
                });
            }
            
            // Remove game control event listeners
            function removeGameControls() {
                document.removeEventListener('mousedown', activateJetpack);
                document.removeEventListener('mouseup', deactivateJetpack);
                document.removeEventListener('touchstart', activateJetpack);
                document.removeEventListener('touchend', deactivateJetpack);
            }
            
            // Event handlers for buttons
            startGameBtn.addEventListener('click', function() {
                selectLevel(0); // Start with level 1
            });
            restartBtn.addEventListener('click', restartGame);
            menuBtn.addEventListener('click', showMainMenu);
            continueBtn.addEventListener('click', continueToNextLevel);
            levelMenuBtn.addEventListener('click', showMainMenu);
            
            function startGame() {
                titleScreen.style.display = 'none';
                gameActive = true;
                levelPaused = false;
                levelIndicator.textContent = `Level: ${currentLevel}`;
                distanceTraveled = 0;
                updateProgress();
                
                // Make sure player is at a valid starting position
                playerY = gameContainer.clientHeight / 2;
                player.style.bottom = `${playerY}px`;
                
                addGameControls();
                gameLoop();
            }
            
            function showMainMenu() {
                gameOverScreen.style.display = 'none';
                levelCompleteMessage.style.display = 'none';
                titleScreen.style.display = 'flex';
                gameActive = false;
                gameOver = false;
                levelPaused = false;
                resetGameState();
                generateLevelButtons();
            }
            
            function continueToNextLevel() {
                levelCompleteMessage.style.display = 'none';
                levelPaused = false;
                
                // Move to next level
                currentLevel++;
                levelTarget = levels[currentLevel - 1].distance;
                obstacleFrequency = levels[currentLevel - 1].obstacleFrequency;
                baseGameSpeed = levels[currentLevel - 1].obstacleSpeed;
                gameSpeed = baseGameSpeed;
                distanceTraveled = 0;
                
                // Update level indicator
                levelIndicator.textContent = `Level: ${currentLevel}`;
                
                // Update background color
                gameContainer.style.backgroundColor = levels[currentLevel - 1].background;
                
                // Generate new background elements
                generateBackgroundElements(currentLevel - 1);
                
                updateProgress();
                
                // Resume game loop
                gameLoop();
            }
            
            function updatePlayerPosition() {
                if (isJetpackActive) {
                    playerVelocity += jetpackForce;
                }
                
                playerVelocity -= gravity;
                playerY += playerVelocity;
                
                // Boundary checks
                const maxY = gameContainer.clientHeight - playerHeight - groundHeight;
                const minY = ceilingHeight;
                
                if (playerY > maxY) {
                    playerY = maxY;
                    playerVelocity = 0;
                }
                
                if (playerY < minY) {
                    playerY = minY;
                    playerVelocity = 0;
                }
                
                player.style.bottom = `${playerY}px`;
                
                // Apply tilt based on velocity
                const tiltAngle = Math.max(-20, Math.min(20, playerVelocity * 2));
                player.style.transform = `rotate(${tiltAngle}deg)`;
            }
            
            function createObstacle() {
                if (Math.random() < obstacleFrequency) {
                    // Determine laser type and position
                    let laserType, height, width, bottom, laserClass;
                    const containerHeight = gameContainer.clientHeight;
                    const vw = window.innerWidth / 100;
                    const vh = window.innerHeight / 100;
                    const vmin = Math.min(vh, vw);
                    
                    // Random laser type (vertical or horizontal)
                    if (Math.random() < 0.5) {
                        // Vertical laser
                        laserType = 'vertical';
                        laserClass = 'vertical-laser';
                        width = 0.8 * vmin;
                        
                        // Determine height and position based on level
                        if (currentLevel <= 3) {
                            // Shorter lasers in lower levels
                            height = Math.floor(Math.random() * (containerHeight / 3)) + 50;
                            
                            // Either from ground or ceiling
                            if (Math.random() < 0.5) {
                                bottom = groundHeight;
                            } else {
                                bottom = containerHeight - height - ceilingHeight;
                            }
                        } else if (currentLevel <= 6) {
                            // Medium lasers in middle levels
                            height = Math.floor(Math.random() * (containerHeight / 2)) + 100;
                            
                            // More varied positions
                            const position = Math.random();
                            if (position < 0.4) {
                                bottom = groundHeight;
                            } else if (position < 0.8) {
                                bottom = containerHeight - height - ceilingHeight;
                            } else {
                                // Some floating lasers
                                const availableSpace = containerHeight - groundHeight - ceilingHeight - height;
                                bottom = groundHeight + Math.floor(Math.random() * availableSpace);
                            }
                        } else {
                            // Longer lasers in higher levels
                            height = Math.floor(Math.random() * (containerHeight * 0.7)) + 150;
                            
                            // More challenging positions
                            const position = Math.random();
                            if (position < 0.3) {
                                bottom = groundHeight;
                            } else if (position < 0.6) {
                                bottom = containerHeight - height - ceilingHeight;
                            } else {
                                // More floating lasers
                                const availableSpace = containerHeight - groundHeight - ceilingHeight - height;
                                bottom = groundHeight + Math.floor(Math.random() * availableSpace);
                            }
                        }
                    } else {
                        // Horizontal laser
                        laserType = 'horizontal';
                        laserClass = 'horizontal-laser';
                        height = 0.8 * vmin;
                        width = Math.random() < 0.3 ? 5 * vw : 10 * vw; // Sometimes shorter, sometimes longer
                        
                        // Position horizontal lasers throughout the screen height
                        const minBottom = groundHeight + 5 * vh;
                        const maxBottom = containerHeight - ceilingHeight - 10 * vh;
                        bottom = Math.floor(Math.random() * (maxBottom - minBottom)) + minBottom;
                    }
                    
                    // Create laser emitter (the source of the laser)
                    const createEmitter = (position, isStart) => {
                        const emitter = document.createElement('div');
                        emitter.className = 'laser-emitter';
                        
                        if (laserType === 'vertical') {
                            emitter.style.bottom = isStart ? `${bottom + height - 10}px` : `${bottom - 10}px`;
                            emitter.style.left = `${position - 6}px`;
                        } else {
                            emitter.style.bottom = `${bottom - 6}px`;
                            emitter.style.left = isStart ? `${position - 20}px` : `${position}px`;
                        }
                        
                        gameContainer.appendChild(emitter);
                        
                        return emitter;
                    };
                    
                    // Create the laser beam
                    const laser = document.createElement('div');
                    laser.className = `obstacle ${laserClass}`;
                    
                    laser.style.height = `${height}px`;
                    laser.style.width = `${width}px`;
                    laser.style.bottom = `${bottom}px`;
                    laser.style.left = `${gameContainer.clientWidth}px`;
                    
                    // Add pulsing effect to make the laser look more dynamic
                    laser.style.animation = 'laser-pulse 0.5s infinite alternate';
                    
                    gameContainer.appendChild(laser);
                    
                    // Create emitters
                    let startEmitter, endEmitter;
                    if (laserType === 'vertical') {
                        startEmitter = createEmitter(gameContainer.clientWidth + 4, true);
                        endEmitter = createEmitter(gameContainer.clientWidth + 4, false);
                    } else {
                        startEmitter = createEmitter(gameContainer.clientWidth, true);
                        endEmitter = createEmitter(gameContainer.clientWidth + width, false);
                    }
                    
                    obstacles.push({
                        element: laser,
                        emitters: [startEmitter, endEmitter],
                        position: gameContainer.clientWidth,
                        width: width,
                        height: height,
                        bottom: bottom,
                        type: laserType
                    });
                }
            }
            
            function createCoin() {
                // Coin frequency increases with level
                const coinChance = 0.03 + (currentLevel * 0.005);
                
                if (Math.random() < coinChance) {
                    const coin = document.createElement('div');
                    coin.className = 'coin';
                    
                    const coinSize = 2 * Math.min(window.innerWidth, window.innerHeight) / 100;
                    coin.style.width = `${coinSize}px`;
                    coin.style.height = `${coinSize}px`;
                    
                    let bottom;
                    
                    // Create coin patterns based on level
                    if (currentLevel <= 3) {
                        // Simple coin placement
                        bottom = Math.floor(Math.random() * (gameContainer.clientHeight - groundHeight - ceilingHeight - coinSize)) + groundHeight;
                    } else {
                        // Create coin patterns in higher levels
                        const pattern = Math.random();
                        
                        if (pattern < 0.3) {
                            // Single coins
                            bottom = Math.floor(Math.random() * (gameContainer.clientHeight - groundHeight - ceilingHeight - coinSize)) + groundHeight;
                        } else if (pattern < 0.6) {
                            // Create a horizontal row of coins
                            bottom = Math.floor(Math.random() * (gameContainer.clientHeight - groundHeight - ceilingHeight - coinSize)) + groundHeight;
                            
                            // Add additional coins in a row
                            const count = Math.floor(Math.random() * 3) + 2;
                            for (let i = 1; i < count; i++) {
                                setTimeout(() => {
                                    if (gameActive && !gameOver && !levelPaused) {
                                        const extraCoin = document.createElement('div');
                                        extraCoin.className = 'coin';
                                        extraCoin.style.width = `${coinSize}px`;
                                        extraCoin.style.height = `${coinSize}px`;
                                        extraCoin.style.bottom = `${bottom}px`;
                                        extraCoin.style.left = `${gameContainer.clientWidth}px`;
                                        gameContainer.appendChild(extraCoin);
                                        coins.push({
                                            element: extraCoin,
                                            position: gameContainer.clientWidth,
                                            bottom: bottom,
                                            size: coinSize
                                        });
                                    }
                                }, i * 200);
                            }
                        } else {
                            // Create a vertical line of coins
                            const baseBottom = Math.max(groundHeight + 50, Math.min(gameContainer.clientHeight - 150, Math.floor(Math.random() * (gameContainer.clientHeight - groundHeight - ceilingHeight - 100)) + groundHeight));
                            bottom = baseBottom;
                            
                            // Add additional coins in a column
                            const count = Math.floor(Math.random() * 3) + 2;
                            for (let i = 1; i < count; i++) {
                                setTimeout(() => {
                                    if (gameActive && !gameOver && !levelPaused) {
                                        const extraCoin = document.createElement('div');
                                        extraCoin.className = 'coin';
                                        extraCoin.style.width = `${coinSize}px`;
                                        extraCoin.style.height = `${coinSize}px`;
                                        extraCoin.style.bottom = `${baseBottom + (i * coinSize * 2)}px`;
                                        extraCoin.style.left = `${gameContainer.clientWidth}px`;
                                        gameContainer.appendChild(extraCoin);
                                        coins.push({
                                            element: extraCoin,
                                            position: gameContainer.clientWidth,
                                            bottom: baseBottom + (i * coinSize * 2),
                                            size: coinSize
                                        });
                                    }
                                }, i * 200);
                            }
                        }
                    }
                    
                    coin.style.bottom = `${bottom}px`;
                    coin.style.left = `${gameContainer.clientWidth}px`;
                    
                    // Add shine animation
                    coin.style.animation = 'shine 1s infinite alternate';
                    
                    gameContainer.appendChild(coin);
                    coins.push({
                        element: coin,
                        position: gameContainer.clientWidth,
                        bottom: bottom,
                        size: coinSize
                    });
                }
            }
            
            function createPowerup() {
                // Powerup frequency based on level
                const powerupChance = 0.005 + (currentLevel * 0.001);
                
                if (Math.random() < powerupChance) {
                    const powerup = document.createElement('div');
                    powerup.className = 'powerup';
                    
                    const powerupSize = 3 * Math.min(window.innerWidth, window.innerHeight) / 100;
                    powerup.style.width = `${powerupSize}px`;
                    powerup.style.height = `${powerupSize}px`;
                    
                    // In higher levels, shields become rarer
                    const typeChance = Math.max(0.3, 0.6 - (currentLevel * 0.03));
                    const type = Math.random() < typeChance ? 'shield' : 'invincibility';
                    powerup.classList.add(type);
                    
                    const bottom = Math.floor(Math.random() * (gameContainer.clientHeight - groundHeight - ceilingHeight - powerupSize)) + groundHeight;
                    
                    powerup.style.bottom = `${bottom}px`;
                    powerup.style.left = `${gameContainer.clientWidth}px`;
                    
                    // Add pulsing animation
                    powerup.style.animation = 'pulse 1.5s infinite';
                    
                    gameContainer.appendChild(powerup);
                    powerups.push({
                        element: powerup,
                        position: gameContainer.clientWidth,
                        bottom: bottom,
                        type: type,
                        size: powerupSize
                    });
                }
            }
            
            function moveBackgroundElements() {
                for (let i = 0; i < backgroundElements.length; i++) {
                    backgroundElements[i].position -= backgroundElements[i].speed;
                    backgroundElements[i].element.style.left = `${backgroundElements[i].position}px`;
                    
                    // Reposition background elements that go off-screen
                    if (backgroundElements[i].position + backgroundElements[i].width < 0) {
                        if (backgroundElements[i].type === 'cloud') {
                            backgroundElements[i].position = gameContainer.clientWidth;
                            backgroundElements[i].element.style.left = `${backgroundElements[i].position}px`;
                        } else if (backgroundElements[i].type === 'mountain') {
                            backgroundElements[i].position = gameContainer.clientWidth;
                            backgroundElements[i].element.style.left = `${backgroundElements[i].position}px`;
                        }
                    }
                }
            }
            
            function moveObstacles() {
                for (let i = 0; i < obstacles.length; i++) {
                    obstacles[i].position -= gameSpeed;
                    obstacles[i].element.style.left = `${obstacles[i].position}px`;
                    
                    // Move emitters with the laser
                    if (obstacles[i].emitters) {
                        for (let j = 0; j < obstacles[i].emitters.length; j++) {
                            const emitter = obstacles[i].emitters[j];
                            if (obstacles[i].type === 'vertical') {
                                emitter.style.left = `${obstacles[i].position - 6}px`;
                            } else {
                                // For horizontal lasers, position emitters at start and end
                                if (j === 0) {
                                    emitter.style.left = `${obstacles[i].position - 20}px`;
                                } else {
                                    emitter.style.left = `${obstacles[i].position + obstacles[i].width}px`;
                                }
                            }
                        }
                    }
                    
                    // Remove obstacles that have gone off-screen
                    if (obstacles[i].position + obstacles[i].width < 0) {
                        gameContainer.removeChild(obstacles[i].element);
                        
                        // Remove emitters
                        if (obstacles[i].emitters) {
                            for (const emitter of obstacles[i].emitters) {
                                if (emitter.parentNode === gameContainer) {
                                    gameContainer.removeChild(emitter);
                                }
                            }
                        }
                        
                        obstacles.splice(i, 1);
                        i--;
                    }
                }
            }
            
            function moveCoins() {
                for (let i = 0; i < coins.length; i++) {
                    coins[i].position -= gameSpeed;
                    coins[i].element.style.left = `${coins[i].position}px`;
                    
                    // Remove coins that have gone off-screen
                    if (coins[i].position < 0) {
                        if (coins[i].element.parentNode === gameContainer) {
                            gameContainer.removeChild(coins[i].element);
                        }
                        coins.splice(i, 1);
                        i--;
                    }
                }
            }
            
            function movePowerups() {
                for (let i = 0; i < powerups.length; i++) {
                    powerups[i].position -= gameSpeed;
                    powerups[i].element.style.left = `${powerups[i].position}px`;
                    
                    // Remove powerups that have gone off-screen
                    if (powerups[i].position < 0) {
                        if (powerups[i].element.parentNode === gameContainer) {
                            gameContainer.removeChild(powerups[i].element);
                        }
                        powerups.splice(i, 1);
                        i--;
                    }
                }
            }
            
            function checkCollisions() {
                const playerLeft = playerStartX;
                const playerRight = playerLeft + playerWidth;
                const playerTop = gameContainer.clientHeight - playerY - playerHeight;
                const playerBottom = gameContainer.clientHeight - playerY;
                
                // Check obstacle collisions
                for (let i = 0; i < obstacles.length; i++) {
                    const obsLeft = obstacles[i].position;
                    const obsRight = obsLeft + obstacles[i].width;
                    const obsTop = gameContainer.clientHeight - obstacles[i].bottom - obstacles[i].height;
                    const obsBottom = gameContainer.clientHeight - obstacles[i].bottom;
                    
                    if (playerRight > obsLeft && playerLeft < obsRight &&
                        playerBottom > obsTop && playerTop < obsBottom) {
                        
                        if (isInvincible) {
                            // Invincibility destroys obstacle
                            createInvincibilityEffect(obsLeft, obstacles[i].bottom + obstacles[i].height / 2);
                            
                            // Remove the obstacle
                            if (obstacles[i].element.parentNode === gameContainer) {
                                gameContainer.removeChild(obstacles[i].element);
                            }
                            
                            // Remove emitters
                            if (obstacles[i].emitters) {
                                for (const emitter of obstacles[i].emitters) {
                                    if (emitter.parentNode === gameContainer) {
                                        gameContainer.removeChild(emitter);
                                    }
                                }
                            }
                            
                            obstacles.splice(i, 1);
                            i--;
                        } else if (hasShield) {
                            // Shield protects from one collision
                            hasShield = false;
                            shieldTimeLeft = 0;
                            updatePowerupIndicator();
                            
                            // Create shield break effect
                            createShieldBreakEffect();
                            
                            // Remove the obstacle
                            if (obstacles[i].element.parentNode === gameContainer) {
                                gameContainer.removeChild(obstacles[i].element);
                            }
                            
                            // Remove emitters
                            if (obstacles[i].emitters) {
                                for (const emitter of obstacles[i].emitters) {
                                    if (emitter.parentNode === gameContainer) {
                                        gameContainer.removeChild(emitter);
                                    }
                                }
                            }
                            
                            obstacles.splice(i, 1);
                            i--;
                        } else if (invincibilityGracePeriod > 0) {
                            // Grace period after invincibility also prevents death
                            createInvincibilityEffect(obsLeft, obstacles[i].bottom + obstacles[i].height / 2);
                            
                            // Remove the obstacle
                            if (obstacles[i].element.parentNode === gameContainer) {
                                gameContainer.removeChild(obstacles[i].element);
                            }
                            
                            // Remove emitters
                            if (obstacles[i].emitters) {
                                for (const emitter of obstacles[i].emitters) {
                                    if (emitter.parentNode === gameContainer) {
                                        gameContainer.removeChild(emitter);
                                    }
                                }
                            }
                            
                            obstacles.splice(i, 1);
                            i--;
                        } else {
                            endGame();
                            return;
                        }
                    }
                }
                
                // Check coin collisions
                for (let i = 0; i < coins.length; i++) {
                    const coinLeft = coins[i].position;
                    const coinSize = coins[i].size || 20;
                    const coinRight = coinLeft + coinSize;
                    const coinTop = gameContainer.clientHeight - coins[i].bottom - coinSize;
                    const coinBottom = gameContainer.clientHeight - coins[i].bottom;
                    
                    if (playerRight > coinLeft && playerLeft < coinRight &&
                        playerBottom > coinTop && playerTop < coinBottom) {
                        
                        // Collect coin with effect
                        createCoinCollectEffect(coins[i].position, coins[i].bottom);
                        
                        if (coins[i].element.parentNode === gameContainer) {
                            gameContainer.removeChild(coins[i].element);
                        }
                        coins.splice(i, 1);
                        score += 10;
                        scoreDisplay.textContent = `Score: ${score}`;
                        i--;
                    }
                }
                
                // Check powerup collisions
                for (let i = 0; i < powerups.length; i++) {
                    const powerupLeft = powerups[i].position;
                    const powerupSize = powerups[i].size || 30;
                    const powerupRight = powerupLeft + powerupSize;
                    const powerupTop = gameContainer.clientHeight - powerups[i].bottom - powerupSize;
                    const powerupBottom = gameContainer.clientHeight - powerups[i].bottom;
                    
                    if (playerRight > powerupLeft && playerLeft < powerupRight &&
                        playerBottom > powerupTop && playerTop < powerupBottom) {
                        
                        // Apply powerup with effect
                        createPowerupCollectEffect(powerups[i].type, powerups[i].position, powerups[i].bottom);
                        
                        if (powerups[i].type === 'invincibility') {
                            isInvincible = true;
                            invincibilityTimeLeft = 5 * 60; // 5 seconds at 60fps
                            invincibilityGracePeriod = 2 * 60; // 2 additional seconds of grace
                        } else if (powerups[i].type === 'shield') {
                            hasShield = true;
                            shieldTimeLeft = 10 * 60; // 10 seconds at 60fps
                        }
                        
                        if (powerups[i].element.parentNode === gameContainer) {
                            gameContainer.removeChild(powerups[i].element);
                        }
                        powerups.splice(i, 1);
                        updatePowerupIndicator();
                        i--;
                    }
                }
            }
            
            function createCoinCollectEffect(x, y) {
                const effect = document.createElement('div');
                effect.className = 'effect';
                effect.textContent = '+10';
                effect.style.position = 'absolute';
                effect.style.left = `${x}px`;
                effect.style.bottom = `${y}px`;
                effect.style.color = 'gold';
                effect.style.fontSize = 'calc(14px + 0.4vmin)';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '0 0 5px black';
                effect.style.animation = 'float-up 1s forwards';
                effect.style.pointerEvents = 'none';
                
                gameContainer.appendChild(effect);
                
                setTimeout(() => {
                    if (effect.parentNode === gameContainer) {
                        gameContainer.removeChild(effect);
                    }
                }, 1000);
            }
            
            function createPowerupCollectEffect(type, x, y) {
                const effect = document.createElement('div');
                effect.className = 'effect';
                effect.textContent = type === 'invincibility' ? 'Invincibility!' : 'Shield!';
                effect.style.position = 'absolute';
                effect.style.left = `${x}px`;
                effect.style.bottom = `${y}px`;
                effect.style.color = type === 'invincibility' ? '#FF9500' : '#3498DB';
                effect.style.fontSize = 'calc(14px + 0.4vmin)';
                effect.style.fontWeight = 'bold';
                effect.style.textShadow = '0 0 5px black';
                effect.style.animation = 'float-up 1s forwards';
                effect.style.pointerEvents = 'none';
                
                gameContainer.appendChild(effect);
                
                setTimeout(() => {
                    if (effect.parentNode === gameContainer) {
                        gameContainer.removeChild(effect);
                    }
                }, 1000);
            }
            
            function createShieldBreakEffect() {
                // Add shield break animation around player
                const effect = document.createElement('div');
                effect.className = 'effect';
                effect.style.position = 'absolute';
                effect.style.width = '8vmin';
                effect.style.height = '8vmin';
                effect.style.left = `${playerStartX - 1.5 * vmin}px`;
                effect.style.bottom = `${playerY - 0.5 * vmin}px`;
                effect.style.borderRadius = '50%';
                effect.style.border = '3px solid #3498DB';
                effect.style.animation = 'shield-break 0.5s forwards';
                effect.style.pointerEvents = 'none';
                
                gameContainer.appendChild(effect);
                
                setTimeout(() => {
                    if (effect.parentNode === gameContainer) {
                        gameContainer.removeChild(effect);
                    }
                }, 500);
            }
            
            function createInvincibilityEffect(x, y) {
                // Add explosion effect when invincible player hits obstacle
                const effect = document.createElement('div');
                effect.className = 'effect';
                effect.style.position = 'absolute';
                effect.style.width = '6vmin';
                effect.style.height = '6vmin';
                effect.style.left = `${x - 3 * vmin}px`;
                effect.style.bottom = `${y - 3 * vmin}px`;
                effect.style.borderRadius = '50%';
                effect.style.background = 'radial-gradient(circle, #FF9500, #FF5733)';
                effect.style.animation = 'explosion 0.5s forwards';
                effect.style.pointerEvents = 'none';
                
                gameContainer.appendChild(effect);
                
                setTimeout(() => {
                    if (effect.parentNode === gameContainer) {
                        gameContainer.removeChild(effect);
                    }
                }, 500);
            }
            
            function updatePowerupStatus() {
                if (invincibilityTimeLeft > 0) {
                    invincibilityTimeLeft--;
                    if (invincibilityTimeLeft === 0) {
                        isInvincible = false;
                    }
                }
                
                if (invincibilityGracePeriod > 0 && invincibilityTimeLeft === 0) {
                    invincibilityGracePeriod--;
                }
                
                if (shieldTimeLeft > 0) {
                    shieldTimeLeft--;
                    if (shieldTimeLeft === 0) {
                        hasShield = false;
                    }
                }
                
                updatePowerupIndicator();
                
                // Visual indicators for powerups
                if (isInvincible) {
                    player.style.boxShadow = '0 0 15px 10px #FF9500';
                } else if (invincibilityGracePeriod > 0) {
                    // Fading effect during grace period
                    const opacity = invincibilityGracePeriod / (2 * 60);
                    player.style.boxShadow = `0 0 15px 10px rgba(255, 149, 0, ${opacity})`;
                } else if (hasShield) {
                    player.style.boxShadow = '0 0 10px 5px #3498DB';
                } else {
                    player.style.boxShadow = 'none';
                }
            }
            
            function updatePowerupIndicator() {
                let indicatorText = '';
                
                if (isInvincible) {
                    indicatorText += `Invincibility: ${Math.ceil(invincibilityTimeLeft / 60)}s `;
                } else if (invincibilityGracePeriod > 0) {
                    indicatorText += `Grace Period: ${Math.ceil(invincibilityGracePeriod / 60)}s `;
                }
                
                if (hasShield) {
                    indicatorText += `Shield: ${Math.ceil(shieldTimeLeft / 60)}s`;
                }
                
                powerupIndicator.textContent = indicatorText;
            }
            
            function updateScore() {
                score++;
                distanceTraveled += gameSpeed;
                
                updateProgress();
                
                // Check for level completion
                if (distanceTraveled >= levelTarget) {
                    completeLevel();
                }
                
                scoreDisplay.textContent = `Score: ${score}`;
            }
            
            function updateProgress() {
                const progressPercentage = Math.min(100, (distanceTraveled / levelTarget) * 100);
                progressBar.style.width = `${progressPercentage}%`;
            }
            
            function completeLevel() {
                // Mark level as completed
                if (!completedLevels.includes(currentLevel - 1)) {
                    completedLevels.push(currentLevel - 1);
                    localStorage.setItem('completedLevels', JSON.stringify(completedLevels));
                }
                
                // Pause the game
                levelPaused = true;
                
                // Update level complete message
                completedLevelSpan.textContent = currentLevel;
                nextLevelSpan.textContent = currentLevel + 1;
                
                // Show "all levels complete" message if it's the last level
                if (currentLevel === levels.length) {
                    levelCompleteMessage.querySelector('h2').textContent = "Congratulations!";
                    levelCompleteMessage.querySelector('p').textContent = "You've completed all levels!";
                    continueBtn.style.display = 'none';
                } else {
                    // Reset normal level complete message
                    levelCompleteMessage.querySelector('h2').textContent = "Level Complete!";
                    levelCompleteMessage.querySelector('p').textContent = `You completed Level ${currentLevel}!`;
                    nextLevelSpan.textContent = currentLevel + 1;
                    continueBtn.style.display = 'inline-block';
                }
                
                // Show level complete screen
                levelCompleteMessage.style.display = 'block';
            }
            
            function endGame() {
                gameOver = true;
                gameActive = false;
                finalScoreDisplay.textContent = `Your Score: ${score}`;
                
                // Check for high score
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('highScore', highScore);
                    highScoreDisplay.textContent = `High Score: ${highScore}`;
                    newHighScoreText.style.display = 'block';
                } else {
                    newHighScoreText.style.display = 'none';
                }
                
                gameOverScreen.style.display = 'block';
                
                // Clean up event listeners
                removeGameControls();
                
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            }
            
            function resetGameState() {
                // Clear all elements
                while (obstacles.length > 0) {
                    if (obstacles[0].element.parentNode === gameContainer) {
                        gameContainer.removeChild(obstacles[0].element);
                    }
                    
                    // Remove emitters
                    if (obstacles[0].emitters) {
                        for (const emitter of obstacles[0].emitters) {
                            if (emitter.parentNode === gameContainer) {
                                gameContainer.removeChild(emitter);
                            }
                        }
                    }
                    
                    obstacles.shift();
                }
                
                while (coins.length > 0) {
                    if (coins[0].element.parentNode === gameContainer) {
                        gameContainer.removeChild(coins[0].element);
                    }
                    coins.shift();
                }
                
                while (powerups.length > 0) {
                    if (powerups[0].element.parentNode === gameContainer) {
                        gameContainer.removeChild(powerups[0].element);
                    }
                    powerups.shift();
                }
                
                while (backgroundElements.length > 0) {
                    if (backgroundElements[0].element.parentNode === gameContainer) {
                        gameContainer.removeChild(backgroundElements[0].element);
                    }
                    backgroundElements.shift();
                }
                
                // Remove any lingering effects
                const effects = document.querySelectorAll('.effect');
                for (const effect of effects) {
                    if (effect.parentNode === gameContainer) {
                        gameContainer.removeChild(effect);
                    }
                }
                
                // Reset game state
                isJetpackActive = false;
                playerY = gameContainer.clientHeight / 2;
                playerVelocity = 0;
                gameSpeed = 5;
                baseGameSpeed = 5;
                score = 0;
                distanceTraveled = 0;
                hasShield = false;
                shieldTimeLeft = 0;
                isInvincible = false;
                invincibilityTimeLeft = 0;
                invincibilityGracePeriod = 0;
                player.style.boxShadow = 'none';
                
                // Reset game container color
                gameContainer.style.backgroundColor = '#87CEEB';
                
                // Reset UI
                scoreDisplay.textContent = 'Score: 0';
                powerupIndicator.textContent = '';
                levelCompleteMessage.style.display = 'none';
                gameOverScreen.style.display = 'none';
                jetpackFlame.style.opacity = '0';
                
                // Reset progress bar
                progressBar.style.width = '0%';
                
                // Reset player position and rotation
                player.style.bottom = `${groundHeight + 10}px`;
                player.style.transform = 'rotate(0deg)';
                document.querySelector('.player-arm.left').style.transform = 'rotate(0deg)';
                document.querySelector('.player-arm.right').style.transform = 'rotate(0deg)';
            }
            
            function restartGame() {
                resetGameState();
                gameOver = false;
                gameActive = true;
                levelPaused = false;
                currentLevel = 1;
                levelTarget = levels[0].distance;
                obstacleFrequency = levels[0].obstacleFrequency;
                baseGameSpeed = levels[0].obstacleSpeed;
                gameSpeed = baseGameSpeed;
                
                // Update level indicator
                levelIndicator.textContent = `Level: ${currentLevel}`;
                
                // Generate background elements
                generateBackgroundElements(0);
                
                addGameControls();
                gameLoop();
            }
            
            function gameLoop() {
                if (gameActive && !gameOver && !levelPaused) {
                    updatePlayerPosition();
                    createObstacle();
                    createCoin();
                    createPowerup();
                    moveBackgroundElements();
                    moveObstacles();
                    moveCoins();
                    movePowerups();
                    checkCollisions();
                    updatePowerupStatus();
                    updateScore();
                    
                    animationFrameId = requestAnimationFrame(gameLoop);
                }
            }
            
            // Add CSS animations
            const style = document.createElement('style');
            style.textContent = `
                @keyframes float-up {
                    0% { transform: translateY(0); opacity: 1; }
                    100% { transform: translateY(-50px); opacity: 0; }
                }
                
                @keyframes shield-break {
                    0% { transform: scale(1); opacity: 1; }
                    100% { transform: scale(2); opacity: 0; }
                }
                
                @keyframes explosion {
                    0% { transform: scale(0.5); opacity: 1; }
                    50% { transform: scale(1.2); opacity: 0.8; }
                    100% { transform: scale(1.5); opacity: 0; }
                }
                
                @keyframes pulse {
                    0% { transform: scale(1); }
                    50% { transform: scale(1.1); }
                    100% { transform: scale(1); }
                }
                
                @keyframes shine {
                    0% { box-shadow: 0 0 5px gold; }
                    100% { box-shadow: 0 0 15px gold; }
                }
                
                @keyframes laser-pulse {
                    0% { opacity: 0.7; box-shadow: 0 0 10px #FF005C; }
                    100% { opacity: 1; box-shadow: 0 0 15px #FF005C; }
                }
            `;
            document.head.appendChild(style);
            
            // Get viewport unit equivalents for calculations
            const vh = window.innerHeight / 100;
            const vw = window.innerWidth / 100;
            const vmin = Math.min(vh, vw);
            
            // Generate initial level buttons
            generateLevelButtons();
        });
    </script>
</body>
</html>